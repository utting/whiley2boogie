#!/usr/bin/env bash
verbose=""
if [[ "$#" > 0 ]]
then
    SCRIPT_PATH=$(dirname `which $0`)
    echo "SCRIPT=$SCRIPT_PATH"
    if [[ "$1" == "--verbose" ]]
    then
        verbose="--verbose"
        shift
    fi
    for w in "$@"
    do
        echo "===== $w ====="
        rm -f "${w%.whiley}.beg"
        # NOTE: this was just: wy boogie "$w" && boogie ...
        # But wy does not return exit status correctly.
        # So we flip stderr and stdout and use awk to set exit status 1 on compile errors.
        # Works, but Yuck!
        wy boogie $verbose --output="${w%.whiley}" "$w" 3>&1 1>&2 2>&3 |awk 'BEGIN{s=0} {print $0; if ($0 ~ "^ *\\^+" || $0 ~ "NotImplementedYet:") s=1} END{exit s}' &&
        # Note: we use Z3 array theory, because it handles large arrays much better (like Byte_Valid*.whiley).
        boogie /useArrayTheory /timeLimit:10 /printModel:4 "/printModelToFile:${w%.whiley}.beg" $SCRIPT_PATH/../wval.bpl "${w%.whiley}.bpl"
        if [[ -r "${w%.whiley}.beg" ]]
        then
            # translate Boogie counter example models back to Whiley-like syntax
            wy boogie $verbose --counterexample ${w%.whiley}.beg
        fi
    done
else
    echo "Usage: $0 *.whiley"
fi

